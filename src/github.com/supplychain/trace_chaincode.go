package main

import (
	"encoding/json"
	"errors"
	"fmt"
	"runtime"
	"time"
	"github.com/hyperledger/fabric/core/chaincode/shim"
	pb "github.com/hyperledger/fabric/protos/peer"
)
///////////////////////////////////////////////////////////////////////////////////////
//
// data model
//
///////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////
// A Map that holds ObjectNames and the number of Keys
// This information is used to dynamically Create, Update
// Replace , and Query the Ledger
// In this model all attributes in a table are strings
// The chain code does both validation
// A dummy key like 2016 in some cases is used for a query to get all rows
//
//              "SkuTraceRecordObj":                      4, Key: TraceCode,SkuId,AddressHash,StationType
//              "SkuAuthenticationTraceRecordObj":        4, Key: TraceCode,SkuId,AddressHash,CertificationBodyType
//              "SkuBaseInfoObj":                         1, Key: TraceCode
//              "SkuTransactionObj":                      4, Key: TraceCode, OrderId, SkuId, TransType
//              "CertificationAccountInfoObj":            1, Key: Name
//              "AccountInfoObj":                         1, Key: Name
//
// The additional key is the ObjectType (aka ObjectName or Object). The keys  would be
// keys: {"picname", "https://raw.githubusercontent.com/ITPeople-Blockchain/auction/v0.6/art/artchaincode/art1.png"}
////////////////SKU的流转信息/////////////////////////////////////////////////////////////////////////////////////
type SkuTraceRecordObj struct {
	SkuId          string//SKU编码
	AddressHash    string
	TraceCode      string //
	StationType    string
	BatchNum       string //
	StationName    string
	ExpressNum     string //
	Signature      string // This is validated for a user registered record
	PreStation     string //
	NextStation    string
	ExtJsonData    string //
	BeginTime      string
	EndTime        string
	TimeStamp      string // This is the time stamp
}
//SKU认证信息
type SkuAuthenticationTraceRecordObj struct {
	SkuId          string
	AddressHash    string
	TraceCode      string //
	CertificationBodyType    string
	BatchNum       string //
	CertificationBodyName    string
	Signature      string // This is certification body signature for a registered sku
	ExtJsonData    string //
	BeginTime      string
	EndTime        string
	TimeStamp      string // This is the time stamp
}
//SKU基础信息
type SkuBaseInfoObj struct {
	SkuId          string
	VendorCode     string //
	TraceCode      string
	AddressHash    string
	Name           string
	BatchNum       string // This is generated by the AES Algorithms
	ExtJsonData    string //
	Signature      string // This is validated for a user registered record
	TimeStamp      string // This is the time stamp
}
//账号信息
type AccountInfoObj struct {
	Name           string
	AccountType    string
	PublicKey      string
	OrgName        string
	TimeStamp      string // This is the time stamp
}
//认证信息
type CertificationAccountInfoObj struct {
	Name           string
	AccountType    string
	PublicKey      string
	OrgName        string
	TimeStamp      string // This is the time stamp
}
//SKU交易信息
type SkuTransactionObj struct {
	OrderId        string
	SkuId          string
	TraceCode      string
	TransType      string // Sale, Buy, Commission
	BatchNum       string // This is generated by the AES Algorithms
	AccountNo      string
	Num            string //
	ExtJsonData    string //
	Signature      string // This is validated for a user registered record
	TransDate      string // This is the time stamp
}


//////////////////////////////////////////////////////////////
// Invoke Functions based on Function name
// The function name gets resolved to one of the following calls
// during an invoke
// peer chaincode  instantiate -v 1.0 -n test_trace -p github.com/hyperledger/fabric/examples/chaincode/go/trace_chaincode -c '{"Args":["init","a","100","b","200"]}' -o orderer0:7050
//////////////////////////////////////////////////////////////
func InvokeFunction(fname string) func(stub shim.ChaincodeStubInterface, args []string) pb.Response {
	InvokeFunc := map[string]func(stub shim.ChaincodeStubInterface, args []string) pb.Response{
		"iPostAccountInfo":                     PostAccountInfo,
		"iPostSkuTransaction":                  PostSkuTransaction,
		"iPostSkuTransactionArrary":           PostSkuTransactionArrary,
		"iPostCertificationAccountInfo":        PostCertificationAccountInfo,
		"iPostSkuAuthenticationTraceRecord":    PostSkuAuthenticationTraceRecord,
		"iPostSkuTraceRecord":                  PostSkuTraceRecord,
		"iPostSkuTraceRecordArrary":           PostSkuTraceRecordArray,
		"iPostSkuBaseInfo":                     PostSkuBaseInfo,
		"iPostTransactionId":                   PostTransactionId,
		"iUpdateAccountInfo":                   UpdateAccountInfo,
		"iUpdateSkuTransaction":                UpdateSkuTransaction,
		"iUpdateCertificationAccountInfo":      UpdateCertificationAccountInfo,
		"iUpdateSkuAuthenticationTraceRecord":  UpdateSkuAuthenticationTraceRecord,
		"iUpdateSkuTraceRecord":                UpdateSkuTraceRecord,
		"iUpdateSkuBaseInfo":                   UpdateSkuBaseInfo,
	}
	return InvokeFunc[fname]
}

//////////////////////////////////////////////////////////////
// Query Functions based on Function name
//
//////////////////////////////////////////////////////////////
func QueryFunction(fname string) func(stub shim.ChaincodeStubInterface, args []string) pb.Response {
	QueryFunc := map[string]func(stub shim.ChaincodeStubInterface, args []string) pb.Response{
		"qGetAccountInfoByAddressHash":                        	GetAccountInfoByAddressHash,
		"qGetSkuBaseInfoByTraceCode":                           GetSkuBaseInfoByTraceCode,
		"qGetCertificationAccountInfoByAddressHash":     	GetCertificationAccountInfoByAddressHash,
		"qGetSkuAuthenticationRecordListByTraceCode":           GetSkuAuthenticationRecordListByTraceCode,
		"qGetSkuTraceRecordListByTraceCode":                    GetSkuTraceRecordListByTraceCode,
		"qGetSkuTransactionListByTraceCode":                    GetSkuTransactionListByTraceCode,
	}
	return QueryFunc[fname]
}

//  Main trace chain code struct
type TraceChainCode struct {

}
////////////////////////////////////////////////////////////////////////////////
// Chain Code Kick-off Main function
////////////////////////////////////////////////////////////////////////////////
func main() {
	// maximize CPU usage for maximum performance
	runtime.GOMAXPROCS(runtime.NumCPU())
	currentDate:=time.Now().Format("2016-07-02 09.45.00:")
	fmt.Sprintf("Starting TraceChainCode Application chaincode at Date : %s",currentDate)

	// Start the shim -- running the fabric
	err := shim.Start(new(TraceChainCode))
	if err != nil {
		fmt.Sprintf("Error starting TraceChainCode Application chaincode: %s", err)
	}

}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// TraceChaincode - Init TraceChaincode implementation - The following sequence of transactions can be used to test the Chaincode
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

func (t *TraceChainCode) Init(stub shim.ChaincodeStubInterface) pb.Response {

	// Uses aucTables to delete tables if they exist and re-create them
	//myLogger.Info("[Product Trace chain code Application] Init")
	fmt.Println("[Product Trace chain code Application] Init")

	fmt.Println("\nInit() Initialization Complete ")
	return shim.Success(nil)
}

func (t *TraceChainCode) Invoke(stub shim.ChaincodeStubInterface) pb.Response {

	function, args := stub.GetFunctionAndParameters()
	fmt.Println("==========================================================")
	fmt.Println("BEGIN Function ====> ", function)
	if function[0:1] == "i" {
		fmt.Println("==========================================================")
		return t.invoke(stub, function, args)
	}

	if function[0:1] == "q" {
		fmt.Println("==========================================================")
		return t.query(stub, function, args)
	}

	fmt.Println("==========================================================")

	return shim.Error("Invoke: Invalid Function Name - function names begin with a q or i")

}

func (t *TraceChainCode) invoke(stub shim.ChaincodeStubInterface, function string, args []string) pb.Response {

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Check Type of Transaction and apply business rules
	// before adding record to the block chain
	// In this version, the assumption is that args[1] specifies recType for all defined structs
	// Newer structs - the recType can be positioned anywhere and ChkReqType will check for recType
	// example:
	// peer chaincode invoke -n test_trace -c '{"Function": "PostItem","Args":["b","a"]}' -o orderer0:7050
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	InvokeRequest := InvokeFunction(function)
	if InvokeRequest != nil {
		response := InvokeRequest(stub, args)
		return (response)
	} else {
		fmt.Println("Invoke() Invalid recType : ", args)
		error_str := "Invoke : Invalid recType : " +function+","+args[0]
		return shim.Error(error_str)
	}

	return shim.Success(nil)
}
//////////////////////////////////////////////////////////////////////////////////////////
// SimpleChaincode - query Chaincode implementation
// Client Can Query
// Sample Data
// peer chaincode query -n test_trace -c '{"Function": "GetItem","Args":["b","a"]}' -o orderer0:7050
//////////////////////////////////////////////////////////////////////////////////////////

func (t *TraceChainCode) query(stub shim.ChaincodeStubInterface, function string, args []string) pb.Response {

	// var buff []byte
	var response pb.Response
	fmt.Println("Query() : ID Extracted and Type = ", args[0])
	fmt.Println("Query() : Args supplied : ", args)

	if len(args) < 1 {
		fmt.Println("Query() : Include at least 1 arguments Key ")
		return shim.Error("Query() : Expecting Transation type and Key value for query")
	}

	QueryRequest := QueryFunction(function)
	if QueryRequest != nil {
		response = QueryRequest(stub, args)
	} else {
		fmt.Println("Query() Invalid function call : ", function)
		response_str := "Query() : Invalid function call : " + function
		return shim.Error(response_str)
	}

	if response.Status != shim.OK {
		fmt.Println("Query() Object not found : ", args[0], ",errorMsg:" + response.Message)
		response_str := "Query() : Object not found : " + args[0] + ",errorMsg:" + response.Message
		return shim.Error(response_str)
	}
	return response
}


//////////////////////////////////////////////////////////////////////////////////////////
// Retrieve User Information by Public Key hash value
// example:
// peer chaincode query -n test_trace -c '{"Function": "qGetAccountInfoByAddressHash","Args":["Name"]}' -o orderer0:7050
//////////////////////////////////////////////////////////////////////////////////////////

func GetAccountInfoByAddressHash(stub shim.ChaincodeStubInterface, args []string) pb.Response {
	if len(args) != 1 {
		return shim.Error("Incorrect number of arguments. Expecting 1")
	}
	var err error
	// Get the Object and Display it
	Avalbytes, err := QueryObject(stub, "AccountInfoObj", args)
	if err != nil {
		fmt.Println("GetAccountInfoByAddressHash() : Failed to Query Object ")
		jsonResp := "{\"Error\":\"Failed to get  Object Data for " + args[0] + "\"}"
		return shim.Error(jsonResp)
	}

	if Avalbytes == nil {
		//fmt.Println("GetAccountInfoByAddressHash() : Incomplete Query Object ")
		//jsonResp := "{\"Error\":\"Incomplete information about the key for " + args[0] + "\"}"
		//return shim.Error(jsonResp)
		return shim.Success(nil)
	}

	fmt.Println("GetAccountInfoByAddressHash() : Response : Successfull -")
	return shim.Success(Avalbytes)
}
//////////////////////////////////////////////////////////////////////////////////////////
// Retrieve User Information by Public Key hash value
// example:
// peer chaincode query -n test_trace -c '{"Function": "qGetCertificationAccountInfoByAddressHash","Args":["Name"]}' -o orderer0:7050
////////////////////////////////////////////////////////////////////////////////////////////
func GetCertificationAccountInfoByAddressHash(stub shim.ChaincodeStubInterface, args []string) pb.Response {
	if len(args) != 1 {
		return shim.Error("Incorrect number of arguments. Expecting 1")
	}
	var err error

	// Get the Object and Display it
	Avalbytes, err := QueryObject(stub, "CertificationAccountInfoObj", args)
	if err != nil {
		fmt.Println("GetCertificationAccountInfoByAddressHash() : Failed to Query Object ")
		jsonResp := "{\"Error\":\"Failed to get  Object Data for " + args[0] + "\"}"
		return shim.Error(jsonResp)
	}

	if Avalbytes == nil {
		//fmt.Println("GetCertificationAccountInfoByAddressHash() : Incomplete Query Object ")
		//jsonResp := "{\"Error\":\"Incomplete information about the key for " + args[0] + "\"}"
		//return shim.Error(jsonResp)
		return shim.Success(nil)
	}

	fmt.Println("GetCertificationAccountInfoByAddressHash() : Response : Successfull -")
	return shim.Success(Avalbytes)
}

//////////////////////////////////////////////////////////////////////////////////////////
// Retrieve User Information by Public Key hash value
// example:
// peer chaincode query -l golang -n test_trace -c '{"Function": "qGetSkuBaseInfoByTraceCode", "Args": ["TraceCode"]}' -o orderer0:7050
//
//////////////////////////////////////////////////////////////////////////////////////////
func GetSkuBaseInfoByTraceCode(stub shim.ChaincodeStubInterface, args []string) pb.Response {
	if len(args) != 1 {
		return shim.Error("Incorrect number of arguments. Expecting 1")
	}
	var err error
	// Get the Object and Display it
	Avalbytes, err := QueryObject(stub, "SkuBaseInfoObj", args)
	if err != nil {
		fmt.Println("GetSkuBaseInfoByTraceCode() : Failed to Query Object ")
		jsonResp := "{\"Error\":\"Failed to get  Object Data for " + args[0] + "\"}"
		return shim.Error(jsonResp)
	}

	if Avalbytes == nil {
		//fmt.Println("GetSkuBaseInfoByTraceCode() : Incomplete Query Object ")
		//jsonResp := "{\"Error\":\"Incomplete information about the key for " + args[0] + "\"}"
		//return shim.Error(jsonResp)
		return shim.Success(nil)
	}

	fmt.Println("GetSkuBaseInfoByTraceCode() : Response : Successfull -")
	return shim.Success(Avalbytes)
}



//////////////////////////////////////////////////////////
// Converts an User Object to a JSON String
//////////////////////////////////////////////////////////
func AccountInfoToJSON(accountInfo AccountInfoObj) ([]byte, error) {

	ajson, err := json.Marshal(accountInfo)
	if err != nil {
		fmt.Println("AccountInfoToJSON error: ", err)
		return nil, err
	}
	fmt.Println("AccountInfoToJSON created: ", ajson)
	return ajson, nil
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Create a normal AccountInfo Object. The first step is to have users
// peer chaincode invoke -l golang -n test_trace -c '{"Function": "iPostAccountInfo", "Args":["Name", "AccountType",
// "PublicKey", "OrgName", "TimeStamp"]}'  -o orderer0:7050
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
func PostAccountInfo(stub shim.ChaincodeStubInterface, args []string) pb.Response {
	record, err := CreateAccountInfoObj(args[0:]) //
	if err != nil {
		return shim.Error(err.Error())
	}
	buff, err := AccountInfoToJSON(record) //

	if err != nil {
		error_str := "PostAccountInfo() : Failed Cannot create object buffer for write : " + args[1]
		fmt.Println(error_str)
		return shim.Error(error_str)
	} else {
		// Update the ledger with the Buffer Data
		// err = stub.PutState(args[0], buff)
		keys := []string{record.Name}
		err = UpdateObject(stub, "AccountInfoObj", keys, buff)
		if err != nil {
			fmt.Println("PostAccountInfo() : write error while inserting record")
			return shim.Error("PostAccountInfo() : write error while inserting record : Error - " + err.Error())
		}

	}

	return shim.Success(buff)
}

func CreateAccountInfoObj(args []string) (AccountInfoObj, error) {
	var account AccountInfoObj

	// Check there are 11 Arguments
	if len(args) != 5 {
		fmt.Println("CreateAccountInfoObj(): Incorrect number of arguments. Expecting 5 ")
		return account, errors.New("CreateAccountInfoObj() : Incorrect number of arguments. Expecting 5 ")
	}

	account = AccountInfoObj{args[0], args[1], args[2], args[3], args[4]}
	fmt.Println("CreateAccountInfoObj() : AccountInfoObj Object : ", account)

	return account, nil
}


//////////////////////////////////////////////////////////
// Converts an CertificationAccountInfo Object to a JSON String
//////////////////////////////////////////////////////////
func CertificationAccountInfoToJSON(accountInfo CertificationAccountInfoObj) ([]byte, error) {

	ajson, err := json.Marshal(accountInfo)
	if err != nil {
		fmt.Println("CertificationAccountInfoToJSON error: ", err)
		return nil, err
	}
	fmt.Println("CertificationAccountInfoToJSON created: ", ajson)
	return ajson, nil
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Create a normal AccountInfo Object. The first step is to have users
// peer chaincode invoke -l golang -n test_trace -c '{"Function": "iPostCertificationAccountInfo", "Args":["Name", "AccountType",
// "PublicKey", "OrgName", "TimeStamp"]}'  -o orderer0:7050
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
func PostCertificationAccountInfo(stub shim.ChaincodeStubInterface, args []string) pb.Response {

	record, err := CreateCertificationAccountInfoObj(args[0:]) //
	if err != nil {
		return shim.Error(err.Error())
	}
	buff, err := CertificationAccountInfoToJSON(record) //

	if err != nil {
		error_str := "PostCertificationAccountInfo() : Failed Cannot create object buffer for write : " + args[1]
		fmt.Println(error_str)
		return shim.Error(error_str)
	} else {
		// Update the ledger with the Buffer Data
		// err = stub.PutState(args[0], buff)
		keys := []string{record.Name}
		err = UpdateObject(stub, "CertificationAccountInfoObj", keys, buff)
		if err != nil {
			fmt.Println("PostCertificationAccountInfo() : write error while inserting record")
			return shim.Error("PostCertificationAccountInfo() : write error while inserting record : Error - " + err.Error())
		}
	}

	return shim.Success(buff)
}

func CreateCertificationAccountInfoObj(args []string) (CertificationAccountInfoObj, error) {

	var account CertificationAccountInfoObj

	// Check there are 11 Arguments
	if len(args) != 5 {
		fmt.Println("CreateCertificationAccountInfoObj(): Incorrect number of arguments. Expecting 11 ")
		return account, errors.New("CreateCertificationAccountInfoObj() : Incorrect number of arguments. Expecting 11 ")
	}

	account = CertificationAccountInfoObj{args[0], args[1], args[2], args[3], args[4]}
	fmt.Println("CreateCertificationAccountInfoObj() : AccountInfoObj Object : ", account)

	return account, nil
}



//////////////////////////////////////////////////////////
// Converts an SkuTransactionObj Object to a JSON String
//////////////////////////////////////////////////////////
func SkuTransactionToJSON(accountInfo SkuTransactionObj) ([]byte, error) {

	ajson, err := json.Marshal(accountInfo)
	if err != nil {
		fmt.Println("SkuTransactionToJSON error: ", err)
		return nil, err
	}
	fmt.Println("SkuTransactionToJSON created: ", ajson)
	return ajson, nil
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Create a normal AccountInfo Object. The first step is to have users
// peer chaincode invoke -l golang -n test_trace -c '{"Function": "iPostSkuTransaction", "Args":["OrderId", "SkuId","TraceCode",
// "TransType", "BatchNum","AccountNo","Num","ExtJsonData","Signature","TransDate"]}' -o orderer0:7050
// SkuTransactionObj key is Key: OrderId, SkuId, TraceCode,TransType
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
func PostSkuTransaction(stub shim.ChaincodeStubInterface, args []string) pb.Response {

	record, err := CreateSkuTransactionObj(args[0:]) //
	if err != nil {
		return shim.Error(err.Error())
	}
	buff, err := SkuTransactionToJSON(record) //

	if err != nil {
		error_str := "PostSkuTransaction() : Failed Cannot create object buffer for write : " + args[1]
		fmt.Println(error_str)
		return shim.Error(error_str)
	} else {
		// Update the ledger with the Buffer Data
		// err = stub.PutState(args[0], buff)
		keys := []string{record.TraceCode, record.SkuId, record.OrderId, record.TransType}
		err = UpdateObject(stub, "SkuTransactionObj", keys, buff)
		if err != nil {
			fmt.Println("PostSkuTransaction() : write error while inserting record")
			return shim.Error("PostSkuTransaction() : write error while inserting record : Error - " + err.Error())
		}
	}
	return shim.Success(buff)
}
func PostSkuTransactionArrary(stub shim.ChaincodeStubInterface, args []string) pb.Response {

	records, err := CreateSkuTransactionObjArrary(args[0:]) //
	if err != nil {
		return shim.Error(err.Error())
	}
	for i := range records {
		var record = records[i];
		buff, err := SkuTransactionToJSON(record) //

		if err != nil {
			error_str := "PostSkuTransaction() : Failed Cannot create object buffer for write : " + args[1]
			fmt.Println(error_str)
			return shim.Error(error_str)
		} else {
			// Update the ledger with the Buffer Data
			// err = stub.PutState(args[0], buff)
			keys := []string{record.TraceCode, record.SkuId, record.OrderId, record.TransType}
			err = UpdateObject(stub, "SkuTransactionObj", keys, buff)
			if err != nil {
				fmt.Println("PostSkuTransaction() : write error while inserting record")
				return shim.Error("PostSkuTransaction() : write error while inserting record : Error - " + err.Error())
			}
		}
	}

	return shim.Success([]byte("OK"))
}

func CreateSkuTransactionObj(args []string) (SkuTransactionObj, error) {

	var record SkuTransactionObj
	// Check there are 10 Arguments
	if len(args) != 10 {
		fmt.Println("CreateSkuTransactionObj(): Incorrect number of arguments. Expecting 10 ")
		return record, errors.New("CreateSkuTransactionObj() : Incorrect number of arguments. Expecting 10 ")
	}
	record = SkuTransactionObj{args[0], args[1], args[2], args[3], args[4],args[5], args[6], args[7], args[8], args[9]}
	fmt.Println("CreateSkuTransactionObj() : SkuTransactionObj Object : ", record)
	return record, nil
}

func CreateSkuTransactionObjArrary(args []string) ([]SkuTransactionObj, error) {

	var records []SkuTransactionObj
	// Check there are 1 Arguments
	if len(args) != 1 {
		fmt.Println("CreateSkuTransactionObjArrary(): Incorrect number of arguments. Expecting 1 ")
		return records, errors.New("CreateSkuTransactionObjArrary(): Incorrect number of arguments. Expecting 1")
	}
	err := json.Unmarshal([]byte(args[0]),&records)
	if (err!=nil) {
		fmt.Println("Unmarshal to []SkuTransactionObj : ", args[0])
		return records, errors.New("Unmarshal to []SkuTransactionObj : "+args[0])
	}
	return records, nil
}


//////////////////////////////////////////////////////////
// Converts an SkuBaseInfoObj Object to a JSON String
//////////////////////////////////////////////////////////
func SkuBaseInfoToJSON(accountInfo SkuBaseInfoObj) ([]byte, error) {

	ajson, err := json.Marshal(accountInfo)
	if err != nil {
		fmt.Println("SkuTransactionToJSON error: ", err)
		return nil, err
	}
	fmt.Println("SkuTransactionToJSON created: ", ajson)
	return ajson, nil
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Create a normal AccountInfo Object. The first step is to have users
// peer chaincode invoke -l golang -n test_trace -c '{"Function": "iPostSkuBaseInfo", "Args":["SkuId", "VendorCode","TraceCode",
// "AddressHash", "Name","BatchNum","ExtJsonData","Signature","TimeStamp"]}' -o orderer0:7050
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

func PostSkuBaseInfo(stub shim.ChaincodeStubInterface, args []string) pb.Response {

	record, err := CreateSkuBaseInfoObj(args[0:]) //
	if err != nil {
		return shim.Error(err.Error())
	}
	buff, err := SkuBaseInfoToJSON(record) //

	if err != nil {
		error_str := "PostSkuBaseInfo() : Failed Cannot create object buffer for write : " + args[1]
		fmt.Println(error_str)
		return shim.Error(error_str)
	} else {
		// Update the ledger with the Buffer Data
		//keys := []string{record.TraceCode, record.SkuId, record.VendorCode}
		keys := []string{record.SkuId}
		err = UpdateObject(stub, "SkuBaseInfoObj", keys, buff)
		if err != nil {
			fmt.Println("PostSkuBaseInfo() : write error while inserting record")
			return shim.Error("PostSkuBaseInfo() : write error while inserting record : Error - " + err.Error())
		}
	}
	return shim.Success(buff)
}

func PostTransactionId(stub shim.ChaincodeStubInterface, args []string) pb.Response {

	record, err := CreateSkuBaseInfoObj(args[0:]) //
	if err != nil {
		return shim.Error(err.Error())
	}
	buff, err := SkuBaseInfoToJSON(record) //

	if err != nil {
		error_str := "PostSkuBaseInfo() : Failed Cannot create object buffer for write : " + args[1]
		fmt.Println(error_str)
		return shim.Error(error_str)
	} else {
		// Update the ledger with the Buffer Data
		//keys := []string{record.TraceCode, record.SkuId, record.VendorCode}
		keys := []string{record.TraceCode}
		err = UpdateObject(stub, "SkuBaseInfoObj", keys, buff)
		if err != nil {
			fmt.Println("PostSkuBaseInfo() : write error while inserting record")
			return shim.Error("PostSkuBaseInfo() : write error while inserting record : Error - " + err.Error())
		}
	}
	return shim.Success(buff)
}

func CreateSkuBaseInfoObj(args []string) (SkuBaseInfoObj, error) {

	var record SkuBaseInfoObj
	// Check there are 11 Arguments
	if len(args) != 9 {
		fmt.Println("CreateSkuBaseInfoObj(): Incorrect number of arguments. Expecting 11 ")
		return record, errors.New("CreateSkuBaseInfoObj() : Incorrect number of arguments. Expecting 9 ")
	}
	record = SkuBaseInfoObj{args[0], args[1], args[2], args[3], args[4],args[5], args[6], args[7], args[8]}
	fmt.Println("CreateSkuBaseInfoObj() : SkuBaseInfoObj Object : ", record)
	return record, nil
}


//////////////////////////////////////////////////////////
// Converts an SkuAuthenticationTraceRecordObj Object to a JSON String
//////////////////////////////////////////////////////////
func SkuSkuAuthenticationTraceRecordToJSON(accountInfo SkuAuthenticationTraceRecordObj) ([]byte, error) {

	ajson, err := json.Marshal(accountInfo)
	if err != nil {
		fmt.Println("SkuSkuAuthenticationTraceRecordToJSON error: ", err)
		return nil, err
	}
	fmt.Println("SkuSkuAuthenticationTraceRecordToJSON created: ", ajson)
	return ajson, nil
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Create a normal AccountInfo Object. The first step is to have users
// peer chaincode invoke -l golang -n test_trace -c '{"Function": "iPostSkuAuthenticationTraceRecord", "Args":["SkuId", "AddressHash",
// "TraceCode", "CertificationBodyType", "BatchNum","CertificationBodyName","Signature","ExtJsonData","BeginTime","EndTime","TimeStamp"]}' -o orderer0:7050
// SkuAuthenticationTraceRecordObj key is Key: SkuId,AddressHash,TraceCode,CertificationBodyType
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
func PostSkuAuthenticationTraceRecord(stub shim.ChaincodeStubInterface, args []string) pb.Response {

	record, err := CreateSkuAuthenticationTraceRecordObj(args[0:]) //
	if err != nil {
		return shim.Error(err.Error())
	}
	buff, err := SkuSkuAuthenticationTraceRecordToJSON(record) //

	if err != nil {
		error_str := "PostSkuAuthenticationTraceRecord() : Failed Cannot create object buffer for write : " + args[1]
		fmt.Println(error_str)
		return shim.Error(error_str)
	} else {
		// Update the ledger with the Buffer Data
		keys := []string{record.TraceCode, record.SkuId, record.AddressHash, record.CertificationBodyType}
		err = UpdateObject(stub, "SkuAuthenticationTraceRecordObj", keys, buff)
		if err != nil {
			fmt.Println("PostSkuAuthenticationTraceRecord() : write error while inserting record")
			return shim.Error("PostSkuAuthenticationTraceRecord() : write error while inserting record : Error - " + err.Error())
		}
	}
	return shim.Success(buff)
}

func CreateSkuAuthenticationTraceRecordObj(args []string) (SkuAuthenticationTraceRecordObj, error) {

	var record SkuAuthenticationTraceRecordObj
	// Check there are 11 Arguments
	if len(args) != 11{
		fmt.Println("CreateSkuAuthenticationTraceRecordObj(): Incorrect number of arguments. Expecting 11 ")
		return record, errors.New("CreateSkuAuthenticationTraceRecordObj() : Incorrect number of arguments. Expecting 11 ")
	}
	record = SkuAuthenticationTraceRecordObj{args[0], args[1], args[2], args[3], args[4],args[5], args[6], args[7], args[8],args[9], args[10]}
	fmt.Println("CreateSkuAuthenticationTraceRecordObj() : SkuAuthenticationTraceRecordObj Object : ", record)
	return record, nil
}

//////////////////////////////////////////////////////////
// Converts an SkuTraceRecordObj Object to a JSON String
//////////////////////////////////////////////////////////
func SkuTraceRecordToJSON(accountInfo SkuTraceRecordObj) ([]byte, error) {

	ajson, err := json.Marshal(accountInfo)
	if err != nil {
		fmt.Println("SkuTraceRecordToJSON error: ", err)
		return nil, err
	}
	fmt.Println("SkuTraceRecordToJSON created: ", ajson)
	return ajson, nil
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Create a normal AccountInfo Object. The first step is to have users
// peer chaincode invoke -l golang -n test_trace -c '{"Function": "iPostSkuTraceRecord", "Args":["SkuId", "AddressHash",
// "TraceCode", "StationType", "BatchNum","StationName","ExpressNum","Signature","PreStation","NextStation","ExtJsonData",
// "BeginTime","EndTime","TimeStamp"]}' -o orderer0:7050
// SkuTraceRecordObj key is Key: SkuId,AddressHash,TraceCode,StationType
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

func PostSkuTraceRecord(stub shim.ChaincodeStubInterface, args []string) pb.Response {

	record, err := CreateSkuTraceRecordObj(args[0:]) //
	if err != nil {
		return shim.Error(err.Error())
	}
	buff, err := SkuTraceRecordToJSON(record) //

	if err != nil {
		error_str := "PostSkuTraceRecord() : Failed Cannot create object buffer for write : " + args[1]
		fmt.Println(error_str)
		return shim.Error(error_str)
	} else {
		// Update the ledger with the Buffer Data
		keys := []string{record.TraceCode, record.SkuId, record.AddressHash, record.StationType}
		err = UpdateObject(stub, "SkuTraceRecordObj", keys, buff)
		if err != nil {
			fmt.Println("PostSkuTraceRecord() : write error while inserting record")
			return shim.Error("PostSkuTraceRecord() : write error while inserting record : Error - " + err.Error())
		}
	}
	return shim.Success(buff)
}

func PostSkuTraceRecordArray(stub shim.ChaincodeStubInterface, args []string) pb.Response {

	records, err := CreateSkuTraceRecordObjArray(args) //
	if err != nil {
		return shim.Error(err.Error())
	}
	for i := range records{
	    var record = records[i];
		buff, err := SkuTraceRecordToJSON(record) //

		if err != nil {
			error_str := "PostSkuTraceRecord() : Failed Cannot create object buffer for write : " + args[1]
			fmt.Println(error_str)
			return shim.Error(error_str)
		} else {
			// Update the ledger with the Buffer Data
			keys := []string{record.TraceCode, record.SkuId, record.AddressHash, record.StationType}
			err = UpdateObject(stub, "SkuTraceRecordObj", keys, buff)
			if err != nil {
				fmt.Println("PostSkuTraceRecord() : write error while inserting record")
				return shim.Error("PostSkuTraceRecord() : write error while inserting record : Error - " + err.Error())
			}
		}
	}


	return shim.Success([]byte("OK"))
}

func CreateSkuTraceRecordObj(args []string) (SkuTraceRecordObj, error) {

	var record SkuTraceRecordObj
	// Check there are 11 Arguments
	if len(args) != 14{
		fmt.Println("CreateSkuTraceRecordObj(): Incorrect number of arguments. Expecting 14 ")
		return record, errors.New("CreateSkuTraceRecordObj() : Incorrect number of arguments. Expecting 14 ")
	}
	record = SkuTraceRecordObj{args[0], args[1], args[2], args[3], args[4],args[5], args[6], args[7], args[8],args[9], args[10],args[11],args[12], args[13]}
	fmt.Println("CreateSkuTraceRecordObj() : SkuTraceRecordObj Object : ", record)
	return record, nil
}

func CreateSkuTraceRecordObjArray(args []string) ([]SkuTraceRecordObj, error) {

	var records []SkuTraceRecordObj
	// Check there are 11 Arguments
	if len(args) != 1{
		fmt.Println("CreateSkuTraceRecordObjArray(): Incorrect number of arguments. Expecting 1 ")
		return records, errors.New("CreateSkuTraceRecordObjArray() : Incorrect number of arguments. Expecting 1 ")
	}
	err := json.Unmarshal([]byte(args[0]),&records)
	if (err!=nil) {
		fmt.Println("Unmarshal to []CreateSkuTraceRecordObj : ", args[0])
		return records, errors.New("Unmarshal to []CreateSkuTraceRecordObj : "+args[0])
	}
	return records, nil
}

//////////////////////////////////////////////////////////
// Converts an User Object to a JSON String
//////////////////////////////////////////////////////////
func JSONtoAccountInfoObj(areq []byte) (AccountInfoObj, error) {

	ar := AccountInfoObj{}
	err := json.Unmarshal(areq, &ar)
	if err != nil {
		fmt.Println("JSONtoAccountInfoObj error: ", err)
		return ar, err
	}
	return ar, err
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// This function updates the AccountInfoObj
// peer chaincode invoke -l golang -n test_trace -c '{"Function": "iUpdateAccountInfo", "Args":["Name", "AccountType",
// "PublicKey", "OrgName", "TimeStamp"]}' -o orderer0:7050

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
func UpdateAccountInfo(stub shim.ChaincodeStubInterface, args []string) pb.Response {

	// Fetch Auction Object and check its Status
	Avalbytes, err := QueryObject(stub, "AccountInfoObj", []string{args[0]})
	if err != nil {
		fmt.Println("UpdateAccountInfo(): Auction Object Retrieval Failed ")
		return shim.Error("OpenAuctionForBids(): Auction Object Retrieval Failed ")
	}

	acc, err := JSONtoAccountInfoObj(Avalbytes)
	if err != nil {
		fmt.Println("UpdateAccountInfo(): Auction Object Unmarshalling Failed ")
		return shim.Error("UpdateAccountInfo(): Auction Object UnMarshalling Failed ")
	}

	acc.Name = args[0]
	acc.AccountType = args[1]
	acc.PublicKey = args[2]
	acc.OrgName = args[3]
	aucStartDate, err := time.Parse("2006-01-02 15:04:05", args[4])
	acc.TimeStamp = aucStartDate.Format("2006-01-02 15:04:05") // This is the time stamp


	response := ReplaceAccountInfoObj(stub, "AccountInfoObj", acc)
	if response.Status != shim.OK {
		fmt.Println("UpdateAccountInfo(): ReplaceAccountInfoObj() Failed ")
		return shim.Error("UpdateAccountInfo(): ReplaceAccountInfoObj() Failed ")
	}
	buff := response.Payload

	return shim.Success(buff)
}
func ReplaceAccountInfoObj(stub shim.ChaincodeStubInterface, tableName string, ar AccountInfoObj) pb.Response {

	buff, err := AccountInfoToJSON(ar)
	if err != nil {
		fmt.Println("ReplaceAccountInfoObj() : Failed Cannot create object buffer for write : ", ar.Name)
		return shim.Error("ReplaceAccountInfoObj(): Failed Cannot create object buffer for write : " + ar.Name)
	}

	// Update the ledger with the Buffer Data
	//keys := []string{ar.AuctionID, ar.ItemID}
	keys := []string{ar.Name}
	err = ReplaceObject(stub, tableName, keys, buff)
	if err != nil {
		fmt.Println("ReplaceAccountInfoObj() : write error while inserting record")
		return shim.Error(err.Error())
	}
	return shim.Success(buff)
}


//////////////////////////////////////////////////////////
// Converts an User Object to a JSON String
//////////////////////////////////////////////////////////
func JSONtoCertificationAccountInfoObj(areq []byte) (CertificationAccountInfoObj, error) {

	ar := CertificationAccountInfoObj{}
	err := json.Unmarshal(areq, &ar)
	if err != nil {
		fmt.Println("JSONtoCertificationAccountInfoObj error: ", err)
		return ar, err
	}
	return ar, err
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// This function updates the CertificationAccountInfoObj
// peer chaincode invoke -l golang -n test_trace -c '{"Function": "iUpdateCertificationAccountInfo", "Args":["Name", "AccountType",
// "PublicKey", "OrgName", "TimeStamp"]}' -o orderer0:7050

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

func UpdateCertificationAccountInfo(stub shim.ChaincodeStubInterface, args []string) pb.Response {

	// Fetch Auction Object and check its Status
	Avalbytes, err := QueryObject(stub, "CertificationAccountInfoObj", []string{args[0]})
	if err != nil {
		fmt.Println("UpdateCertificationAccountInfo(): Auction Object Retrieval Failed ")
		return shim.Error("UpdateCertificationAccountInfo(): Auction Object Retrieval Failed ")
	}

	acc, err := JSONtoCertificationAccountInfoObj(Avalbytes)
	if err != nil {
		fmt.Println("UpdateCertificationAccountInfo(): Auction Object Unmarshalling Failed ")
		return shim.Error("UpdateCertificationAccountInfo(): Auction Object UnMarshalling Failed ")
	}

	acc.Name = args[0]
	acc.AccountType = args[1]
	acc.PublicKey = args[2]

	acc.OrgName = args[3]
	aucStartDate, err := time.Parse("2006-01-02 15:04:05", args[4])
	acc.TimeStamp = aucStartDate.Format("2006-01-02 15:04:05") // This is the time stamp


	response := ReplaceCertificationAccountInfoObj(stub, "AccountInfoObj", acc)
	if response.Status != shim.OK {
		fmt.Println("UpdateCertificationAccountInfo(): ReplaceCertificationAccountInfoObj() Failed ")
		return shim.Error("UpdateCertificationAccountInfo(): ReplaceCertificationAccountInfoObj() Failed ")
	}
	buff := response.Payload

	return shim.Success(buff)
}
func ReplaceCertificationAccountInfoObj(stub shim.ChaincodeStubInterface, tableName string, ar CertificationAccountInfoObj) pb.Response {

	buff, err := CertificationAccountInfoToJSON(ar)
	if err != nil {
		fmt.Println("ReplaceCertificationAccountInfoObj() : Failed Cannot create object buffer for write : ", ar.Name)
		return shim.Error("ReplaceCertificationAccountInfoObj(): Failed Cannot create object buffer for write : " + ar.Name)
	}

	// Update the ledger with the Buffer Data
	keys := []string{ar.Name}
	err = ReplaceObject(stub, tableName, keys, buff)
	if err != nil {
		fmt.Println("ReplaceCertificationAccountInfoObj() : write error while inserting record")
		return shim.Error(err.Error())
	}
	return shim.Success(buff)
}



//////////////////////////////////////////////////////////
// Converts an User Object to a JSON String
//////////////////////////////////////////////////////////
func JSONtoSkuBaseInfoObj(areq []byte) (SkuBaseInfoObj, error) {

	ar := SkuBaseInfoObj{}
	err := json.Unmarshal(areq, &ar)
	if err != nil {
		fmt.Println("JSONtoSkuBaseInfoObj error: ", err)
		return ar, err
	}
	return ar, err
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// This function updates the SkuBaseInfoObj
// peer chaincode invoke -l golang -n test_trace -c '{"Function": "UpdateSkuBaseInfo", "Args":["SkuId", "VendorCode","TraceCode",
// "AddressHash", "Name","BatchNum","ExtJsonData","Signature","TimeStamp"]}' -o orderer0:7050
// SkuBaseInfoObj key is Key: SkuId,VendorCode,TraceCode

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
func UpdateSkuBaseInfo(stub shim.ChaincodeStubInterface, args []string) pb.Response {

	// Fetch Auction Object and check its Status
	Avalbytes, err := QueryObject(stub, "SkuBaseInfoObj", []string{args[0]})
	if err != nil {
		fmt.Println("UpdateSkuBaseInfo(): Auction Object Retrieval Failed ")
		return shim.Error("UpdateSkuBaseInfo(): Auction Object Retrieval Failed ")
	}

	acc, err := JSONtoSkuBaseInfoObj(Avalbytes)
	if err != nil {
		fmt.Println("UpdateSkuBaseInfo(): Auction Object Unmarshalling Failed ")
		return shim.Error("UpdateSkuBaseInfo(): Auction Object UnMarshalling Failed ")
	}
	acc.SkuId  = args[0]
	acc.VendorCode = args[1]
	acc.TraceCode = args[2]
	acc.AddressHash   =args[3]
	acc.Name  = args[4]
	acc.BatchNum  = args[5]

	acc.ExtJsonData=args[6]
	acc.Signature=args[7]

	aucStartDate, err := time.Parse("2006-01-02 15:04:05", args[8])
	acc.TimeStamp = aucStartDate.Format("2006-01-02 15:04:05") // This is the time stamp


	response := ReplaceSkuBaseInfoObj(stub, "SkuBaseInfoObj", acc)
	if response.Status != shim.OK {
		fmt.Println("UpdateSkuBaseInfo(): ReplaceSkuBaseInfoObj() Failed ")
		return shim.Error("UpdateSkuBaseInfo(): ReplaceSkuBaseInfoObj() Failed ")
	}
	buff := response.Payload

	return shim.Success(buff)
}

func ReplaceSkuBaseInfoObj(stub shim.ChaincodeStubInterface, tableName string, ar SkuBaseInfoObj) pb.Response {

	buff, err := SkuBaseInfoToJSON(ar)
	if err != nil {
		fmt.Println("ReplaceSkuBaseInfoObj() : Failed Cannot create object buffer for write : ", ar.Name)
		return shim.Error("ReplaceSkuBaseInfoObj(): Failed Cannot create object buffer for write : " + ar.Name)
	}
	// Update the ledger with the Buffer Data
	keys := []string{ar.TraceCode}
	err = ReplaceObject(stub, tableName, keys, buff)
	if err != nil {
		fmt.Println("ReplaceSkuBaseInfoObj() : write error while inserting record")
		return shim.Error(err.Error())
	}
	return shim.Success(buff)
}


//////////////////////////////////////////////////////////
// Converts an User Object to a JSON String
//////////////////////////////////////////////////////////
func JSONtoSkuTransactionObj(areq []byte) (SkuTransactionObj, error) {

	ar := SkuTransactionObj{}
	err := json.Unmarshal(areq, &ar)
	if err != nil {
		fmt.Println("JSONtoSkuTransactionObj error: ", err)
		return ar, err
	}
	return ar, err
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Update the SkuTransactionObj Object
// peer chaincode invoke -l golang -n test_trace -c '{"Function": "iUpdateSkuTransaction", "Args":["OrderId", "SkuId","TraceCode",
// "TransType", "BatchNum","AccountNo","Num","ExtJsonData","Signature","TransDate"]}' -o orderer0:7050

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

func UpdateSkuTransaction(stub shim.ChaincodeStubInterface, args []string) pb.Response {

	// Fetch Auction Object and check its Status
	//Avalbytes, err := QueryObject(stub, "SkuTransactionObj", []string{args[0]})
	//if err != nil {
	//	fmt.Println("UpdateSkuTransaction(): Auction Object Retrieval Failed ")
	//	return shim.Error("UpdateSkuTransaction(): Auction Object Retrieval Failed ")
	//}
	//
	//acc, err := JSONtoSkuTransactionObj(Avalbytes)
	//if err != nil {
	//	fmt.Println("UpdateSkuTransaction(): Auction Object Unmarshalling Failed ")
	//	return shim.Error("UpdateSkuTransaction(): Auction Object UnMarshalling Failed ")
	//}
	//
	//
	//acc.OrderId  = args[0]
	//acc.SkuId  = args[1]
	//acc.TraceCode = args[2]
	//acc.TransType = args[3]
	//acc.BatchNum   =args[4]
	//acc.AccountNo  = args[5]
	//acc.Num=args[6]
	//acc.ExtJsonData=args[7]
	//acc.Signature=args[8]
	//
	//aucStartDate, err := time.Parse("2006-01-02 15:04:05", args[9])
	//acc.TransDate=aucStartDate.Format("2006-01-02 15:04:05")
	//
	//
	//response := ReplaceSkuTransactionObj(stub, "SkuTransactionObj", acc)
	//if response.Status != shim.OK {
	//	fmt.Println("UpdateSkuTransaction(): ReplaceSkuTransactionObj() Failed ")
	//	return shim.Error("UpdateSkuTransaction(): ReplaceSkuTransactionObj() Failed ")
	//}
	//buff := response.Payload
	//
	//return shim.Success(buff)

	return shim.Success(nil)
}

func ReplaceSkuTransactionObj(stub shim.ChaincodeStubInterface, tableName string, ar SkuTransactionObj) pb.Response {

	buff, err := SkuTransactionToJSON(ar)
	if err != nil {
		fmt.Println("ReplaceSkuTransactionObj() : Failed Cannot create object buffer for write : ", ar.TraceCode)
		return shim.Error("ReplaceSkuTransactionObj(): Failed Cannot create object buffer for write : " + ar.TraceCode)
	}
	// Update the ledger with the Buffer Data
	keys := []string{ar.TraceCode}
	err = ReplaceObject(stub, tableName, keys, buff)
	if err != nil {
		fmt.Println("ReplaceSkuTransactionObj() : write error while inserting record")
		return shim.Error(err.Error())
	}
	return shim.Success(buff)
}


func UpdateSkuTraceRecord(stub shim.ChaincodeStubInterface, args []string) pb.Response {

	return shim.Success(nil)
}

func UpdateSkuAuthenticationTraceRecord(stub shim.ChaincodeStubInterface, args []string) pb.Response {

	return shim.Success(nil)
}

//////////////////////////////////////////////////////////
// Converts an User Object to a JSON String
//////////////////////////////////////////////////////////
func JSONtoSkuAuthenticationTraceRecordObj(args []byte) (SkuAuthenticationTraceRecordObj, error) {

	ar := SkuAuthenticationTraceRecordObj{}
	err := json.Unmarshal(args, &ar)
	if err != nil {
		fmt.Println("JSONtoSkuAuthenticationTraceRecordObj error: ", err)
		return ar, err
	}
	return ar, err
}
/////////////////////////////////////////////////////////////////////////////////////////////////////
// Get List of SKU authentication record for an TraceCode
// in the block-chain --
// peer chaincode query -l golang -n test_trace -c '{"Function": "qGetSkuAuthenticationRecordListByTraceCode", "Args": ["1111"]}' -o orderer0:7050
/////////////////////////////////////////////////////////////////////////////////////////////////////
func GetSkuAuthenticationRecordListByTraceCode(stub shim.ChaincodeStubInterface, args []string) pb.Response {
	if len(args) != 1 {
		return shim.Error("Incorrect number of arguments. Expecting 1")
	}
	rs, err := GetList(stub, "SkuAuthenticationTraceRecordObj", args)
	if err != nil {
		error_str := fmt.Sprintf("GetSkuAuthenticationRecordListByTraceCode operation failed. Error marshaling JSON: %s", err)
		return shim.Error(error_str)
	}

	defer rs.Close()

	// Iterate through result set
	var i int
	var tlist []SkuAuthenticationTraceRecordObj // Define a list
	for i = 0; rs.HasNext(); i++ {

		// We can process whichever return value is of interest
		_, value, err := rs.Next()
		if err != nil {
			return shim.Success(nil)
		}
		bid, err := JSONtoSkuAuthenticationTraceRecordObj(value)
		if err != nil {
			error_str := fmt.Sprintf("GetSkuAuthenticationRecordListByTraceCode() operation failed - Unmarshall Error. %s", err)
			fmt.Println(error_str)
			return shim.Error(error_str)
		}
		fmt.Println("GetList() : my Value : ", bid)
		tlist = append(tlist, bid)
	}

	jsonRows, err := json.Marshal(tlist)
	if err != nil {
		error_str := fmt.Sprintf("GetSkuAuthenticationRecordListByTraceCode() operation failed - Unmarshall Error. %s", err)
		fmt.Println(error_str)
		return shim.Error(error_str)
	}

	fmt.Println("List of SkuAuthenticationTraceRecordObj Requested : ", jsonRows)
	return shim.Success(jsonRows)

}

//////////////////////////////////////////////////////////
// Converts an User Object to a JSON String
//////////////////////////////////////////////////////////
func JSONtoSkuTraceRecordObj(areq []byte) (SkuTraceRecordObj, error) {

	ar := SkuTraceRecordObj{}
	err := json.Unmarshal(areq, &ar)
	if err != nil {
		fmt.Println("SkuTraceRecordObj error: ", err)
		return ar, err
	}
	return ar, err
}
/////////////////////////////////////////////////////////////////////////////////////////////////////
// Get List of SKU trace record for an TraceCode
// in the block-chain --
// peer chaincode query -l golang -n test_trace -c '{"Function": "qGetSkuTraceRecordListByTraceCode", "Args": ["1111"]}' -o orderer0:7050
/////////////////////////////////////////////////////////////////////////////////////////////////////
func GetSkuTraceRecordListByTraceCode(stub shim.ChaincodeStubInterface, args []string) pb.Response {
	if len(args) != 1 {
		return shim.Error("Incorrect number of arguments. Expecting 1")
	}
	rs, err := GetList(stub, "SkuTraceRecordObj", args)
	if err != nil {
		error_str := fmt.Sprintf("GetSkuTraceRecordListByTraceCode operation failed. Error marshaling JSON: %s", err)
		return shim.Error(error_str)
	}

	defer rs.Close()

	// Iterate through result set
	var i int
	var tlist []SkuTraceRecordObj // Define a list
	for i = 0; rs.HasNext(); i++ {

		// We can process whichever return value is of interest
		_, value, err := rs.Next()
		if err != nil {
			return shim.Success(nil)
		}
		bid, err := JSONtoSkuTraceRecordObj(value)
		if err != nil {
			error_str := fmt.Sprintf("GetSkuTraceRecordListByTraceCode() operation failed - Unmarshall Error. %s", err)
			fmt.Println(error_str)
			return shim.Error(error_str)
		}
		fmt.Println("GetSkuTraceRecordListByTraceCode() : my Value : ", bid)
		tlist = append(tlist, bid)
	}

	jsonRows, err := json.Marshal(tlist)
	if err != nil {
		error_str := fmt.Sprintf("GetSkuTraceRecordListByTraceCode() operation failed - Unmarshall Error. %s", err)
		fmt.Println(error_str)
		return shim.Error(error_str)
	}

	fmt.Println("List of SkuTraceRecordObj Requested : ", jsonRows)
	return shim.Success(jsonRows)

}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// Get List of SKU trade record for an TraceCode
// in the block-chain --
// peer chaincode query -l golang -n test_trace -c '{"Function": "qGetSkuTransactionListByTraceCode", "Args": ["1111"]}' -o orderer0:7050
/////////////////////////////////////////////////////////////////////////////////////////////////////
func GetSkuTransactionListByTraceCode(stub shim.ChaincodeStubInterface, args []string) pb.Response {
	if len(args) != 1 {
		return shim.Error("Incorrect number of arguments. Expecting 1")
	}
	rs, err := GetList(stub, "SkuTransactionObj", args)
	if err != nil {
		error_str := fmt.Sprintf("GetSkuTransactionListByTraceCode operation failed. Error marshaling JSON: %s", err)
		return shim.Error(error_str)
	}

	defer rs.Close()

	// Iterate through result set
	var i int
	var tlist []SkuTransactionObj // Define a list
	for i = 0; rs.HasNext(); i++ {

		// We can process whichever return value is of interest
		_, value, err := rs.Next()
		if err != nil {
			return shim.Success(nil)
		}
		bid, err := JSONtoSkuTransactionObj(value)
		if err != nil {
			error_str := fmt.Sprintf("GetSkuTransactionListByTraceCode() operation failed - Unmarshall Error. %s", err)
			fmt.Println(error_str)
			return shim.Error(error_str)
		}
		fmt.Println("GetSkuTransactionListByTraceCode() : my Value : ", bid)
		tlist = append(tlist, bid)
	}

	jsonRows, err := json.Marshal(tlist)
	if err != nil {
		error_str := fmt.Sprintf("GetSkuTransactionListByTraceCode() operation failed - Unmarshall Error. %s", err)
		fmt.Println(error_str)
		return shim.Error(error_str)
	}

	fmt.Println("List of SkuTransactionObj Requested : ", jsonRows)
	return shim.Success(jsonRows)
}